{"ast":null,"code":"import { createAsyncThunk, createSlice } from \"@reduxjs/toolkit\";\nimport httpClient from \"../apiClient/httpClient\";\n\n// Middleare for handling all asynchoronus operations.\n// export const fetchProducts = createAsyncThunk<IProduct[]>(\"products/list\", \n//   async() => await httpClient.get(`http://localhost:4200/products`))\n\n// Taking the input as string and return IProduct[] array.\nexport const fetchProducts = createAsyncThunk(\"products/search\", async (searchKey = \"\") => await httpClient.get(`http://localhost:9999/api/products?productName=${searchKey}`));\n// Initializing type of AppStateType.\nconst initialState = {\n  products: [],\n  error: false,\n  searchKey: \"\"\n};\n/*\n  Because of Slice , we also export the reducers as well.\n*/\nexport const productListSlice = createSlice({\n  name: 'products',\n  initialState: initialState,\n  reducers: {\n    // We are setting the search key from action.payload.\n    setSearchKey: (state, action) => {\n      state.searchKey = action.payload;\n    }\n  },\n  extraReducers: builder => {\n    // It helps you to look for different promise state , \n    // to check whether the promise is resolved or rejected.\n    // This is where we aim to go and fetch\n\n    // it resolves createAsyncThunks.\n    builder.addCase(fetchProducts.fulfilled, (state, action) => {\n      state.products = action.payload;\n    });\n    builder.addCase(fetchProducts.rejected, state => {\n      state.error = true;\n    });\n  }\n});\nexport const {\n  setSearchKey\n} = productListSlice.actions;\nexport default productListSlice.reducer;","map":{"version":3,"names":["createAsyncThunk","createSlice","httpClient","fetchProducts","searchKey","get","initialState","products","error","productListSlice","name","reducers","setSearchKey","state","action","payload","extraReducers","builder","addCase","fulfilled","rejected","actions","reducer"],"sources":["C:/Users/SanketNayak/Documents/New1/mernstack/frontend/src/redux/producListSlice.tsx"],"sourcesContent":["import { createAsyncThunk,createSlice } from \"@reduxjs/toolkit\";\nimport IProduct from \"../model/product\";\nimport httpClient from \"../apiClient/httpClient\";\n\n\n// Middleare for handling all asynchoronus operations.\n// export const fetchProducts = createAsyncThunk<IProduct[]>(\"products/list\", \n//   async() => await httpClient.get(`http://localhost:4200/products`))\n\n// Taking the input as string and return IProduct[] array.\nexport const fetchProducts = createAsyncThunk<IProduct[],string>(\"products/search\", \n  async(searchKey:string=\"\") => await httpClient.get(`http://localhost:9999/api/products?productName=${searchKey}`))\n\n\ntype AppStateType = {\n    products: IProduct[],\n    error:boolean,\n    searchKey:string,\n}\n\n// Initializing type of AppStateType.\nconst initialState : AppStateType = {\n    products:[],\n    error:false,\n    searchKey:\"\",\n}\n/*\n  Because of Slice , we also export the reducers as well.\n*/\nexport const productListSlice = createSlice({\n    name:'products',\n    initialState: initialState,\n    reducers:{\n        // We are setting the search key from action.payload.\n        setSearchKey: (state,action) => {\n            state.searchKey = action.payload\n        }\n    },\n    extraReducers: (builder)=> {\n        // It helps you to look for different promise state , \n        // to check whether the promise is resolved or rejected.\n        // This is where we aim to go and fetch\n\n        // it resolves createAsyncThunks.\n        builder.addCase(fetchProducts.fulfilled , \n            (state,action) => {state.products = action.payload})\n\n        builder.addCase(fetchProducts.rejected , (state) =>{state.error = true})\n    }\n})\n\nexport const {setSearchKey} = productListSlice.actions\nexport default productListSlice.reducer"],"mappings":"AAAA,SAASA,gBAAgB,EAACC,WAAW,QAAQ,kBAAkB;AAE/D,OAAOC,UAAU,MAAM,yBAAyB;;AAGhD;AACA;AACA;;AAEA;AACA,OAAO,MAAMC,aAAa,GAAGH,gBAAgB,CAAoB,iBAAiB,EAChF,OAAMI,SAAgB,GAAC,EAAE,KAAK,MAAMF,UAAU,CAACG,GAAG,CAAE,kDAAiDD,SAAU,EAAC,CAAC,CAAC;AASpH;AACA,MAAME,YAA2B,GAAG;EAChCC,QAAQ,EAAC,EAAE;EACXC,KAAK,EAAC,KAAK;EACXJ,SAAS,EAAC;AACd,CAAC;AACD;AACA;AACA;AACA,OAAO,MAAMK,gBAAgB,GAAGR,WAAW,CAAC;EACxCS,IAAI,EAAC,UAAU;EACfJ,YAAY,EAAEA,YAAY;EAC1BK,QAAQ,EAAC;IACL;IACAC,YAAY,EAAEA,CAACC,KAAK,EAACC,MAAM,KAAK;MAC5BD,KAAK,CAACT,SAAS,GAAGU,MAAM,CAACC,OAAO;IACpC;EACJ,CAAC;EACDC,aAAa,EAAGC,OAAO,IAAI;IACvB;IACA;IACA;;IAEA;IACAA,OAAO,CAACC,OAAO,CAACf,aAAa,CAACgB,SAAS,EACnC,CAACN,KAAK,EAACC,MAAM,KAAK;MAACD,KAAK,CAACN,QAAQ,GAAGO,MAAM,CAACC,OAAO;IAAA,CAAC,CAAC;IAExDE,OAAO,CAACC,OAAO,CAACf,aAAa,CAACiB,QAAQ,EAAIP,KAAK,IAAI;MAACA,KAAK,CAACL,KAAK,GAAG,IAAI;IAAA,CAAC,CAAC;EAC5E;AACJ,CAAC,CAAC;AAEF,OAAO,MAAM;EAACI;AAAY,CAAC,GAAGH,gBAAgB,CAACY,OAAO;AACtD,eAAeZ,gBAAgB,CAACa,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}